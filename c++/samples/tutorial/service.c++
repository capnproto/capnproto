#include "pch.h"
#include "secure.h"

extern kj::Own<kj::PromiseFulfiller<void>> g_terminate;

// This is a sample server. Sample::Server is generated by the capnp tool from interface.capnp
// The functions add one concept at a time.
// As you read through the examples, note the function names are based on the names from interface.capnp

struct CSample final: public Sample::Server
{
	// simpleFunction @0 ();
	kj::Promise<void> simpleFunction(SimpleFunctionContext context)
	{
		return kj::READY_NOW;
	}

	// oneParam @1 (variable :UInt16);
	kj::Promise<void> oneParam(OneParamContext context)
	{
		unsigned short variable = context.getParams().getVariable();
		return kj::READY_NOW;
	}

	// notImpl @2 ();
	// not implemented, because I didn't want to renumber or reuse @2 in the .capnp file.
	// This will happen to you.
	// The caller will get an exception if they try to call this function

	// responder @3 () -> (answer :UInt32);
	kj::Promise<void> responder(ResponderContext context)
	{
		context.getResults().setAnswer(42);
		return kj::READY_NOW;
	}

	// echo @4 (input :Float32) -> (response :Float32);
	kj::Promise<void> echo(EchoContext context)
	{
		float variable = context.getParams().getInput();
		context.getResults().setResponse(variable);
		return kj::READY_NOW;
	}

	// collect @5 (v1 :UInt64, v2 :UInt64, v3 :UInt64) -> (reply :List(UInt64));
	kj::Promise<void> collect(CollectContext context)
	{
		auto params = context.getParams();
		uint64_t v1 = params.getV1();
		uint64_t v2 = params.getV2();
		uint64_t v3 = params.getV3();

		// List size must be initialized before anything is written
		auto list = context.getResults().initReply(3);
		list.set(0, v1);
		list.set(1, v2);
		list.set(2, v3);

		return kj::READY_NOW;
	}
	
	// separate @6 (param :List(UInt64)) -> (v1 :UInt64, v2 :UInt64, v3 :UInt64);
	kj::Promise<void> separate(SeparateContext context)
	{
		auto list = context.getParams().getParam();
		if (list.size() != 3)
			KJ_FAIL_REQUIRE("separate() list must have exactly 3 numbers");

		auto results = context.getResults();
		results.setV1(list[0]);
		results.setV2(list[1]);
		results.setV3(list[2]);
		return kj::READY_NOW;
	}
	
	// setState @7 (happy :Bool);
	kj::Promise<void> setState(SetStateContext context)
	{
		happy = context.getParams().getHappy();
		return kj::READY_NOW;
	}

	// getState @8 () -> (happy :Bool);
	kj::Promise<void> getState(GetStateContext context)
	{
		context.getResults().setHappy(happy);
		return kj::READY_NOW;
	}

	// echoStruct @9 (str :ExampleStruct);
	kj::Promise<void> echoStruct(EchoStructContext context)
	{
		auto reader = context.getParams().getStr();
		auto writer = context.getResults().getStr();
		writer.setA(reader.getA());
		writer.setB(reader.getB());
		return kj::READY_NOW;
	}

	// echoData @10 (d :Data) -> (d :Data);
	kj::Promise<void> echoData(EchoDataContext context)
	{
		auto in = context.getParams().getD().asBytes();
		auto results = context.getResults();
		results.initD(in.size());
		auto out = results.getD();

		for (size_t i = 0; i < in.size(); ++i)
			out[i] = in[i];
		return kj::READY_NOW;
	}

	bool happy = false;
};

struct CRoot final: public Root::Server
{
	// getSample @0 () -> (v :Sample);
	kj::Promise<void> getSample(GetSampleContext context)
	{
		context.getResults().setV(kj::heap<CSample>());
		return kj::READY_NOW;
	}

	// getSecure @1 (password :UInt64) -> (v :Secure);
	kj::Promise<void> getSecure(GetSecureContext context)
	{
		uint64_t password = context.getParams().getPassword();
		if (password != 42)
			KJ_FAIL_REQUIRE("bad password");
		context.getResults().setV(kj::heap<CSecure>());
		return kj::READY_NOW;
	}
};

int main()
{
	kj::AsyncIoContext ioContext = kj::setupAsyncIo();
	capnp::TwoPartyServer server(kj::heap<CRoot>());
	auto address = ioContext.provider->getNetwork().parseAddress("127.0.0.1", 2001).wait(ioContext.waitScope);
	auto listener = address->listen();
	auto listenPromise = server.listen(*listener);

	kj::PromiseFulfillerPair<void> paf = kj::newPromiseAndFulfiller<void>();
	g_terminate = kj::mv(paf.fulfiller);

	// Create a promise that fulfills on SIGINT (aka CTRL-C from the terminal).
	// Join it with the g_terminate promise and wait until either is fulfilled
	ioContext.unixEventPort.onSignal(SIGINT).ignoreResult().exclusiveJoin(kj::mv(paf.promise)).wait(ioContext.waitScope);

	// An alternate way is to uncomment the following two lines
	//signalInit();
	//paf.promise.wait(ioContext.waitScope);
}