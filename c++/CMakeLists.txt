cmake_minimum_required(VERSION 2.8)
if(COMMAND cmake_policy)
  cmake_policy(SET CMP0003 NEW)
endif(COMMAND cmake_policy)

# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
# set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_CXX_FLAGS "-std=c++11 -fpermissive ${CMAKE_CXX_FLAGS}")

## Process this file with automake to produce Makefile.in

# ACLOCAL_AMFLAGS = -I m4

# AUTOMAKE_OPTIONS = foreign subdir-objects

# Always include gtest in distributions.
# DIST_SUBDIRS = $(subdirs)

# Build gtest before we build Cap'n Proto tests.  We don't add gtest to SUBDIRS
# because then "make check" would also build and run all of gtest's own tests,
# which takes a lot of time and is generally not useful to us.  Also, we don't
# want "make install" to recurse into gtest since we don't want to overwrite
# the installed version of gtest if there is one (and, actually, gtest doesn't
# even support "make install" anyway).  So we define a rule such that it will
# only be built when needed.
# gtest/lib/libgtest:
# 	@echo "Making lib/libgtest.a lib/libgtest_main.a in gtest"
# 	@cd gtest && $(MAKE) $(AM_MAKEFLAGS) lib/libgtest lib/libgtest_main

# gtest/lib/libgtest_main: gtest/lib/libgtest
# 	@:

add_subdirectory(gtest)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/gtest/include)

# We would like to clean gtest when "make clean" is invoked.  But we have to
# be careful because clean-local is also invoked during "make distclean", but
# "make distclean" already recurses into gtest because it's listed among the
# DIST_SUBDIRS.  distclean will delete gtest/Makefile, so if we then try to
# cd to the directory again and "make clean" it will fail.  So, check that the
# Makefile exists before recursing.
# clean-local:
# 	@if test -e gtest/Makefile; then \
# 	  echo "Making clean in gtest"; \
# 	  cd gtest && $(MAKE) $(AM_MAKEFLAGS) clean; \
# 	fi

# AM_CXXFLAGS = -I$(srcdir)/src -I$(builddir)/src $(PTHREAD_CFLAGS)

# AM_LDFLAGS = $(PTHREAD_CFLAGS)

# EXTRA_DIST =
#   README.txt
#   LICENSE.txt
#   $(test_capnpc_inputs)
#   src/capnp/compiler/capnp-test.sh
#   src/capnp/testdata/segmented-packed
#   src/capnp/testdata/errors.capnp.nobuild
#   src/capnp/testdata/short.txt
#   src/capnp/testdata/flat
#   src/capnp/testdata/binary
#   src/capnp/testdata/errors.txt
#   src/capnp/testdata/segmented
#   src/capnp/testdata/packed
#   src/capnp/testdata/pretty.txt

# CLEANFILES = $(test_capnpc_outputs) test_capnpc_middleman

# Deletes all the files generated by autoreconf.
# MAINTAINERCLEANFILES =   \
#   aclocal.m4             \
#   config.guess           \
#   config.sub             \
#   configure              \
#   depcomp                \
#   install-sh             \
#   ltmain.sh              \
#   Makefile.in            \
#   missing                \
#   mkinstalldirs          \
#   config.h.in            \
#   stamp.h.in             \
#   m4/ltsugar.m4          \
#   m4/libtool.m4          \
#   m4/ltversion.m4        \
#   m4/lt~obsolete.m4      \
#   m4/ltoptions.m4

# maintainer-clean-local:
# 	-rm -rf build-aux

# gmake defines an implicit rule building n from n.o.  Unfortunately, this triggers on our .capnp
# files because they generate .capnp.c++ which is compiled to .capnp.o.  In addition to being
# nonsense, this leads to cyclic dependency issues and could even cause the .capnp files to be
# unexpectedly overwritten!  We need to cancel the implicit rule by declaring an explicit one.
#
# I want the hours of my life back that I spent figuring this out.
# %.capnp:
# 	@:

set(public_capnpc_inputs
  src/capnp/c++.capnp
  src/capnp/schema.capnp
)

set(capnpc_inputs
  $(public_capnpc_inputs)
  src/capnp/rpc.capnp
  src/capnp/rpc-twoparty.capnp
  src/capnp/compiler/lexer.capnp
  src/capnp/compiler/grammar.capnp
)

set(capnpc_outputs
  src/capnp/c++.capnp.c++
  src/capnp/c++.capnp.h
  src/capnp/schema.capnp.c++
  src/capnp/schema.capnp.h
  src/capnp/rpc.capnp.c++
  src/capnp/rpc.capnp.h
  src/capnp/rpc-twoparty.capnp.c++
  src/capnp/rpc-twoparty.capnp.h
  src/capnp/compiler/lexer.capnp.c++
  src/capnp/compiler/lexer.capnp.h
  src/capnp/compiler/grammar.capnp.c++
  src/capnp/compiler/grammar.capnp.h
)

# includecapnpdir = $(includedir)/capnp
# includekjdir = $(includedir)/kj
# includekjparsedir = $(includekjdir)/parse

# dist_includecapnp_DATA = $(public_capnpc_inputs)

# includekj_HEADERS =
#   src/kj/common.h
#   src/kj/units.h
#   src/kj/memory.h
#   src/kj/refcount.h
#   src/kj/array.h
#   src/kj/vector.h
#   src/kj/string.h
#   src/kj/string-tree.h
#   src/kj/exception.h
#   src/kj/debug.h
#   src/kj/arena.h
#   src/kj/io.h
#   src/kj/tuple.h
#   src/kj/one-of.h
#   src/kj/function.h
#   src/kj/mutex.h
#   src/kj/thread.h
#   src/kj/async-prelude.h
#   src/kj/async.h
#   src/kj/async-inl.h
#   src/kj/async-unix.h
#   src/kj/async-io.h
#   src/kj/main.h

# includekjparse_HEADERS =
#   src/kj/parse/common.h
#   src/kj/parse/char.h

# includecapnp_HEADERS =
#   src/capnp/c++.capnp.h
#   src/capnp/common.h
#   src/capnp/blob.h
#   src/capnp/endian.h
#   src/capnp/layout.h
#   src/capnp/orphan.h
#   src/capnp/list.h
#   src/capnp/object.h
#   src/capnp/message.h
#   src/capnp/capability.h
#   src/capnp/capability-context.h
#   src/capnp/schema.capnp.h
#   src/capnp/schema.h
#   src/capnp/schema-loader.h
#   src/capnp/schema-parser.h
#   src/capnp/dynamic.h
#   src/capnp/pretty-print.h
#   src/capnp/serialize.h
#   src/capnp/serialize-async.h
#   src/capnp/serialize-packed.h
#   src/capnp/pointer-helpers.h
#   src/capnp/generated-header-support.h
#   src/capnp/rpc.h
#   src/capnp/rpc-twoparty.h
#   src/capnp/rpc.capnp.h
#   src/capnp/rpc-twoparty.capnp.h

set(lib_LTLIBRARIES libkj libkj-async libcapnp libcapnp-rpc libcapnpc)

# libkj_LDFLAGS = -release $(VERSION) -no-undefined
add_library(libkj
  src/kj/common.c++
  src/kj/units.c++
  src/kj/memory.c++
  src/kj/refcount.c++
  src/kj/array.c++
  src/kj/string.c++
  src/kj/string-tree.c++
  src/kj/exception.c++
  src/kj/debug.c++
  src/kj/arena.c++
  src/kj/io.c++
  src/kj/mutex.c++
  src/kj/thread.c++
  src/kj/main.c++
  src/kj/parse/char.c++
)
set_target_properties(libkj PROPERTIES PREFIX "")
target_link_libraries(libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

# libkj-async_LDFLAGS = -release $(VERSION) -no-undefined
add_library(libkj-async
  src/kj/async.c++
  src/kj/async-unix.c++
  src/kj/async-io.c++
)
set_target_properties(libkj-async PROPERTIES PREFIX "")
target_link_libraries(libkj-async
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

# libcapnp_LDFLAGS = -release $(VERSION) -no-undefined
add_library(libcapnp
  src/capnp/c++.capnp.c++
  src/capnp/blob.c++
  src/capnp/arena.h
  src/capnp/arena.c++
  src/capnp/layout.c++
  src/capnp/list.c++
  src/capnp/object.c++
  src/capnp/message.c++
  src/capnp/schema.capnp.c++
  src/capnp/schema.c++
  src/capnp/schema-loader.c++
  src/capnp/dynamic.c++
  src/capnp/stringify.c++
  src/capnp/serialize.c++
  src/capnp/serialize-packed.c++
)
set_target_properties(libcapnp PROPERTIES PREFIX "")
target_link_libraries(libcapnp
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

# libcapnp-rpc_LDFLAGS = -release $(VERSION) -no-undefined
add_library(libcapnp-rpc
  src/capnp/serialize-async.c++
  src/capnp/capability.c++
  src/capnp/capability-context.c++
  src/capnp/dynamic-capability.c++
  src/capnp/rpc.c++
  src/capnp/rpc.capnp.c++
  src/capnp/rpc-twoparty.c++
  src/capnp/rpc-twoparty.capnp.c++
)
set_target_properties(libcapnp-rpc PROPERTIES PREFIX "")
target_link_libraries(libcapnp-rpc
  libcapnp
  libkj-async
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)



# libcapnpc_LDFLAGS = -release $(VERSION) -no-undefined
add_library(libcapnpc
  src/capnp/compiler/md5.h
  src/capnp/compiler/md5.c++
  src/capnp/compiler/error-reporter.h
  src/capnp/compiler/error-reporter.c++
  src/capnp/compiler/lexer.capnp.h
  src/capnp/compiler/lexer.capnp.c++
  src/capnp/compiler/lexer.h
  src/capnp/compiler/lexer.c++
  src/capnp/compiler/grammar.capnp.h
  src/capnp/compiler/grammar.capnp.c++
  src/capnp/compiler/parser.h
  src/capnp/compiler/parser.c++
  src/capnp/compiler/node-translator.h
  src/capnp/compiler/node-translator.c++
  src/capnp/compiler/compiler.h
  src/capnp/compiler/compiler.c++
  src/capnp/schema-parser.c++
)
set_target_properties(libcapnpc PROPERTIES PREFIX "")
target_link_libraries(libcapnpc
  libcapnp
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

# bin_PROGRAMS = capnp capnpc-capnp capnpc-c++

add_executable(capnp
  src/capnp/compiler/module-loader.h
  src/capnp/compiler/module-loader.c++
  src/capnp/compiler/capnp.c++
)
target_link_libraries(capnp
  libcapnpc
  libcapnp
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

add_executable(capnpc-capnp
  src/capnp/compiler/capnpc-capnp.c++
)
target_link_libraries(capnpc-capnp
  libcapnp
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

add_executable(capnpc-c++
  src/capnp/compiler/capnpc-c++.c++
)
target_link_libraries(capnpc-c++
  libcapnp
  libkj
  ${CMAKE_THREAD_LIBS_LINK}
)

# Symlink capnpc -> capnp.  The capnp binary will behave like the old capnpc
# binary (i.e. like "capnp compile") when invoked via this symlink.
#
# Also attempt to run ldconfig, because otherwise users get confused.  If
# it fails (e.g. because the platform doesn't have it, or because the
# user doesn't have root privileges), don't worry about it.
# install-exec-hook:
# 	ln -sf capnp $(DESTDIR)$(bindir)/capnpc
# 	ldconfig < /dev/null > /dev/null 2>&1 || true

# uninstall-hook:
# 	rm -f $(DESTDIR)$(bindir)/capnpc

# Source files intentionally not included in the dist at this time:
#  src/capnp/serialize-snappy*
#  src/capnp/benchmark/...
#  src/capnp/compiler/...

# Tests ==============================================================
enable_testing()

set(test_capnpc_inputs
  src/capnp/test.capnp
  src/capnp/test-import.capnp
  src/capnp/test-import2.capnp
)

set(test_capnpc_outputs
  src/capnp/test.capnp.c++
  src/capnp/test.capnp.h
  src/capnp/test-import.capnp.c++
  src/capnp/test-import.capnp.h
  src/capnp/test-import2.capnp.c++
  src/capnp/test-import2.capnp.h
)

if(USE_EXTERNAL_CAPNP)
  set(CAPNP_EXECUTABLE "*location*")
else(USE_EXTERNAL_CAPNP)
  get_target_property(CAPNP_EXECUTABLE capnp LOCATION)
endif(USE_EXTERNAL_CAPNP)

# the first for stuff the compiled files include,
# the second for the compiled files theselves
include_directories(
  ${CMAKE_CURRENT_SOURCE_DIR}/src
  ${CMAKE_BINARY_DIR}/src
)

foreach(filename ${test_capnpc_inputs})
  add_custom_command(
    DEPENDS capnp capnpc-c++ ${filename}
    COMMAND ${CAPNP_EXECUTABLE}
    ARGS compile --src-prefix=${CMAKE_CURRENT_SOURCE_DIR}/src -o${CMAKE_BINARY_DIR}/capnpc-c++:src -I${CMAKE_CURRENT_SOURCE_DIR}/src ${CMAKE_CURRENT_SOURCE_DIR}/${filename}
    OUTPUT "${filename}.h" "${filename}.c++"
    COMMENT "Compiling ${filename} into ${filename}.h and ${filename}.c++"
  )
endforeach()


add_custom_target(ttt DEPENDS "src/capnp/test.capnp.c++")

# BUILT_SOURCES = $(test_capnpc_outputs)

if(0)
  add_executable(capnp_test
    src/kj/common-test.c++
    src/kj/memory-test.c++
    src/kj/refcount-test.c++
    src/kj/array-test.c++
    src/kj/string-test.c++
    src/kj/string-tree-test.c++
    src/kj/exception-test.c++
    src/kj/debug-test.c++
    src/kj/arena-test.c++
    src/kj/units-test.c++
    src/kj/tuple-test.c++
    src/kj/one-of-test.c++
    src/kj/function-test.c++
    src/kj/mutex-test.c++
    src/kj/async-test.c++
    src/kj/async-unix-test.c++
    src/kj/async-io-test.c++
    src/kj/parse/common-test.c++
    src/kj/parse/char-test.c++
    src/capnp/common-test.c++
    src/capnp/blob-test.c++
    src/capnp/endian-test.c++
    src/capnp/endian-fallback-test.c++
    src/capnp/endian-reverse-test.c++
    src/capnp/layout-test.c++
    src/capnp/object-test.c++
    src/capnp/message-test.c++
    src/capnp/capability-test.c++
    src/capnp/schema-test.c++
    src/capnp/schema-loader-test.c++
    src/capnp/dynamic-test.c++
    src/capnp/stringify-test.c++
    src/capnp/encoding-test.c++
    src/capnp/orphan-test.c++
    src/capnp/serialize-test.c++
    src/capnp/serialize-async-test.c++
    src/capnp/serialize-packed-test.c++
    src/capnp/rpc-test.c++
    src/capnp/rpc-twoparty-test.c++
    src/capnp/test-util.c++
    src/capnp/test-util.h
    src/capnp/compiler/lexer-test.c++
    src/capnp/compiler/md5-test.c++
  )
  add_test(capnp_test capnp_test)
  foreach(filename ${test_capnpc_outputs})
    add_dependencies(capnp_test ${filename})
  endforeach()
  target_link_libraries(capnp_test
    gtest
    libkj
    libcapnp
    libcapnpc
    libkj-async
    libcapnp-rpc
  )
  # nodist_capnp_test_SOURCES = $(test_capnpc_outputs)
endif(0)

add_executable(capnp_evolution_test
  src/capnp/compiler/evolution-test.c++
)
get_target_property(CAPNP_EVOLUTION_TEST_EXECUTABLE capnp_evolution_test LOCATION)
add_test(capnp_evolution_test ${CAPNP_EVOLUTION_TEST_EXECUTABLE})
target_link_libraries(capnp_evolution_test
  libcapnpc
  libcapnp
  libkj
)

add_test(capnp-test-interface
  ${CMAKE_CURRENT_SOURCE_DIR}/src/capnp/compiler/capnp-test.sh
)
